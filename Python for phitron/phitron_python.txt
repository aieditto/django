                                                #Introduction to python
                                       
                                       #Date 1st 1st module date: 17th june,2023
                                                     #Module 1.3:
                                          #Basic data type and variable in python

"""python no need to declare any data type for the variable so it was easy to handle and most easy language".
"""
# age = 45
# print(age)
# collusion = "substitute"
# print(collusion)
# is_signle = True
# print(is_signle)

# #to know the type of the variable
# is_single=True
# print(type(is_signle))
# is_singele="Fuck you"
# print(type(is_singele))

                                  #Module 1.4 Basic input and output typecasting
# #How to take input
# money = input("Give me money:")
# print("here is money:" ,money)

# # When we add some values and use input() function but 
# # that time it take as a string so we have to apply typecast  for
# # changing the data type. Here are some example

# firstmoney=input("Enter money 1: ")
# secondmoney=input("Enter money 2: ")
# first=int(firstmoney)
# second=int(secondmoney)
# total=first+second
# print("Total money:",total)




                                # python 2nd day 2nd module date sat, 27 may, 2023
                                                    # fucntion

"""
2.1 introduction to function in python
indentation means space it work as a bracket.

def is called define.
function likte gele def likte hoi
"""
# def double_it(num):
#     result=num*2
#     print(result)

# double_it(8)
# double_it(88)

# def sum(num1,num2):
#     result= num1+num2
#     return result
# total = sum(23,45)
# print(total)

"""
2.2 Default parameters and args in python


"""
# def sum(num1,num2,num3): 
#     # """this are called argument where the value add at the bracket"""
#     result= num1+num2+num3
#     return result
# total = sum(99,11,5) 
# # """this are called parameter where the value add at the bracket"""
# print('total:',total)

# """jodi parameter 2ta pataite hoi but argument 3ta rakte hoi
# tahole j parameter ta patabona shetak 0 diye assign korte hbe jemon
# num3=0
# """
# def sum(num1,num2,num3=0): 
#     # """this are called argument where the value add at the bracket"""
#     result= num1+num2+num3
#     return result
# total = sum(99,11) 
# # """this are called parameter where the value add at the bracket"""
# print('total:',total)

"""
If i need to add many number on the arguments but I dont no how many numbers
need to add there also I dont want to add num=0 repeatedly. That's why tupple are use.
Tupple is like one kind of array or list.

what is tupple?
A tuple is a data structure in programming that is used to store multiple elements together. 
It is an ordered collection of values, enclosed in parentheses and separated by commas. 
Tuples are similar to lists or Array, but they are immutable, meaning their elements cannot be modified once they are created.
Tuples can contain elements of different data types, such as integers, floats, strings, or even other tuples.

The procude for write tupple:
def all_sum(*numbers): //here adding (*) before the arguments are tupple
    print(numbers)

total = all_sum(12,23,5,7,8)
print(total)
"""



#                   #2.3 (advanced) kargs, multiple return from a function
# def func(a,b):
#     nul=f'showing the value: {a},{b}'
#     return nul

# nul=func(1,2)
# print(nul)

#                         #2.4 Local and global variable
# amount = 3000 #global variable
# def take_amount(item,taka):
#     #taka =2000 #local variabl
#     global amount #global  is a keyword use for accesing global variable
#     amount= amount-taka
#     print(f'Show the amount of the {item} ',amount)

# take_amount('Chocolate',1000)


#2.5 Module Built in function and import module
# def taka_dao(taka):
#     Fachis_dinme_paisa_double = 2*taka
#     print(f'Paisa hi paisa hoga now ap bare lok ho apki total amount:',Fachis_dinme_paisa_double)

# taka_dao(20000)

#fiie 2nd
# from function2ndmodule import taka_dao
# taka_dao(5000000)

# 2.6 list 
# #Normal indexing:
#        #0   1  2   3    4  5   6
# list =[10, 11, 12, 23, 45, 67, 8]
#        #-6  -5  -4  -3  -2  -1  0
# #printing value of index 0 to before 2 
# print(list[0:2])
# #printing value of index 1 to before 6 
# print(list[1:6])
# #python has the power of printing without mentioning the index. for example
# # if before and after of colon ':' has no value or given only one value it will automatically
# # produce the 1st or last index 
# print(list[:6])
# print(list[0:])
# print(list[:])
# print(list[1:6:2])
 
                                # Module 3.1
# If i want to write a name with single quotation
# like abdur's rahman then it will show a error
# thats why I have to use (/) 
# example: abdur\'s rahman

# name = 'anisul\'s islam' #this is call escaping
# name2= 'love'
# name3= """Sakiya tuj johor mumu"""
# print(name)
# print(name2)
# print(name3)


#string is a sequence of character
#list are called that means changeable and non-mutable means unchangeable
#string cant be change 
# for example:
# name2[0]='F'
# print(name2)
# this error will be show:
#  File "g:\Python for phitron\function2ndmodule.py", line 174, in <module>
#     name2[0]='F'
#     ~~~~~^^^
# TypeError: 'str' object does not support item assignment
# print(name2[2])#findout the value of input index
# print(name3[::-1])#string canbe reversable
# print(name3[1:6])#string can sliceable

                            
                            
                            # Moudle 3.2
#Tupple is one kind of list where many values are store
# #tupple cant be changeable like assigning any value
# print(len(name))
# item = ([0,2,6],[5,99,7],[4,7,991])
# print(item)
# #After changing the single value of the list of single tupple
# print("After changing the single value")
# item [0][1]= 45
# item [2][0]= 23
# print(item)

 # #Module 3.3 Set and set methods in python
# # Set is a unique item

"""         List --> []

            tupple --> ()
            
            set --> {}
"""
# numbers=[12,56,98,78,56,12,6,98]
# print(numbers)
# number_set=set(numbers)
# print(number_set)

# #number add
# number_set.add(47)
# print(number_set)

# #remove
# number_set.remove(6)
# print(number_set)

# len(number_set)

# A= {5,6,8,9}
# B= {10,6,9}
# print(A&B)
#  other things are on websites

                            
                            
                             #Module-3.4 Dictionary and Dictionary methods in python

# Dictionary is like key value pair
# numbers = [12,56,98,78,56,12,26,98]
# person1 =['Anis', 'Kalipur', 23, 'student']
# # {key: valuem, key: value, key:value}
# person ={'name':'Anis', 'Address': 'Saltgola','Age': 23, 'Job':'Student'}
# print(person)
# print(person['Job'])
# # Dictionaries are mutable so I can change any of the value from the list or tuple
# print("Biyer age")
# person2 ={'Name':'Sakiya Tuj Johora', 'Address': 'Hulaine, Badamtol','Age': 22, 'Profession':'Amr Bou'}
# print(person2)
# print(person2['Profession'])
# print(person2.keys()) #for printing the keys of dictionaries
# print(person2.values())  #for printing the values of dictionaries

# print("Biyer Por")
# person2['Jamai']='Anis'
# print(person2)
# person2['Address']='Anis er bari'
# print(person2)

# other things are found on website

# import pyautogui
# from time import sleep
# sleep(10)

# pyautogui.write("bepar ta kintu moja onk", interval=0.01)
# pyautogui.press('enter',presses=1)


                            
                            
                            
                                Introduction to Simple Class Module 5.1

class is an entity where data and object wrap up together
class carries many info which are used in other class or other place

How to write class and object and use that?

            class class_name:
                instruction

            object = class_name()
            object.instruction= value
            print(object.instruction)
Example:
        # class Class_name:
        #     price=19000
        #     color='blue'
        #     brand='samsung'

        # my_phone=Class_name()
        # print(my_phone)
        # print(my_phone.price)
        # print(my_phone.color)
        # print(my_phone.brand)

        class student:
            id=''
            roll=''
            section=''

        Anis=student()
        Sakiya=student()

        Anis.id= 220238063
        Anis.roll= 63
        Anis.section= 'B'
        print(Anis.id)
        print(Anis.roll)
        print(Anis.section)

        Sakiya.id= 220238048
        Sakiya.roll= 48
        Sakiya.section= 'B'
        print(Sakiya.id)
        print(Sakiya.roll)
        print(Sakiya.section)


                            
                            
                            
                              Module  5.2 Creating and Using Methods

# def function():
#     print('calling someone i dont know')
#     return 'call done'
# class phone:
#     price = 1200
#     color= 'yellow'
#     brand='sandy'
#     features=['camera', 'speaker']
    
#     def call(self): 
#         # self is use for calling the method in class
#         print('calling one person')
    
#     def send_sms(self, xhone, message):
#         text= f'send message to {xhone} and sms {message}'
#         return text

# amar_phone= phone()
# print(amar_phone.features)

# busy= amar_phone.call()
# result= amar_phone.send_sms(233, 'Inky pinky ponky')
# print(result)

class Calculator:
    brand= 'Casio 6251'
    def add(self, num1, num2):
        result= num1+num2
        return result
    def sub(self, num1, num2):
        result2= num1-num2
        return result2

addition=Calculator()
print(addition.brand)
result=addition.add(55,5)
print(result)

result2=addition.sub(5,2)
print(result2)


                        
                        
                        
                              Module  5.3 Constructors and __init__ in python

  # __init__ mean initialize which are use as constructor
  in python class init is use like the constructor
  constructor means a class which have some variable or instruction
  that are use on object  which have similar characteristics
  and it also like the DRY(Django) princle that means Dont Repeat Yourself
  so it give less time complexity and short to typing code repeatedly.

    The Default __init__ Constructor in C++ and Java. Constructors are used to initializing the object’s state. The task of constructors is to initialize(assign values) to the data members of the class when an object of the class is created. Like methods, a constructor also contains a collection of statements(i.e. instructions) that are executed at the time of Object creation. It is run as soon as an object of a class is instantiated. The method is useful to do any initialization you want to do with your object.

 class Phone:
     manufacture ='China'
    
     def __init__(self, owner, brand,price):
         self.owner=owner
         self.brand=brand
         self.price=price
        
       
        
     def send_msg(self, phone, sems):
         text= f'sending to: {phone} {sems}'
         print(text)
    

# my_phone= Phone('Anis', 'tecno', '8500')
# print(my_phone.owner, my_phone.brand, my_phone.price)

class Phone:
    
    def __init__(self, num1, num2):
        self.num1=num1
        self.num2=num2
        
addition=Phone(10,19)
result=addition.num1+addition.num2
print(f'{addition.num1} + {addition.num2} = {result}')

sub=Phone(14,5)
result2=sub.num1-sub.num2
print(f'{sub.num1} - {sub.num2} = {result2}')

                
                
                
                   Module  5.4 Class Attributes vs instance attributes

# Class Attribute VS Instance Attribute

class Shop:
    cart=[] #list declare class attribute this for all not in function
    def __init__(self,buyer): #init funciton for construction
        self.buyer = buyer #attribute declare
        
    def add_to_cart(self, item):
        self.cart.append(item)

customer = Shop('Anisul Islam')
customer.add_to_cart('Audi')
customer.add_to_cart('Ferari')
customer.add_to_cart('Marcedies')
print(customer.cart)

customer2 = Shop('Anisul Islam')
customer2.add_to_cart('Audi')
customer2.add_to_cart('Ferari')
customer2.add_to_cart('Marcedies')
print(customer2.cart)


class Shop:
     
    def __init__(self,buyer): #init funciton for construction
        self.buyer = buyer #attribute declare
        self.cart=[] #instant attribute #list declare  this for all not in function
        
    def add_to_cart(self, item):
        self.cart.append(item)

customer = Shop('Anisul Islam')
customer.add_to_cart('Audi')
customer.add_to_cart('Ferari')
customer.add_to_cart('Marcedies')
print(customer.cart)

customer2 = Shop('Sakiya Islam')
customer2.add_to_cart('Lipstick')
customer2.add_to_cart('Eyeliner')
customer2.add_to_cart('Brush')
print(customer2.cart)

what is the big difference?
the difference is when using class attribute this are for all other function and object
so when two or many object are create and call the class the class attribute work for all of them as a result we see if difference object has different items but the result will show all item in one list. 

But if we use instance attribute
it will work separtely and give the result separately.


                                    
                                    
                                    
                                    
                                    Module- 5.5 Bank System


# class Bank:
#     def __init__(self, balance):
#         self.balance=balance
#         self.min_withdraw=100
#         self.max_withdraw=10000
    
#     def get_balance(self):
#         return self.balance
    
#     def deposit(self, amount):
#         if amount> 0:
#             self.balance += amount
#             print(f'your balance is{self.balance}')
    
#     def withdraw(self,amount):
#         if amount<self.min_withdraw:
#             print(f'Sorry. Minimum withdraw is{self.min_withdraw}')
#         elif amount>self.max_withdraw:
#             print(f'Sorry. Maximum withdraw is {self.max_withdraw}')
#         else:
#             self.balance-=amount
#             print(f'Your Balance {self.get_balance()}')   

# dbl=Bank(5000)
# dbl.withdraw(101)

class Exam:
    
    def __init__(self, person, marks):
        self.person=person
        self.marks=marks
        print(f'student name{self.person}')
        self.minimum_marks=33
    
    # def max(self):
        
    
    def result(self, marks):
        if self.marks>90:
            print(f'you got A+ your marks {self.marks}')
        elif self.marks>= 80 & self.marks<=89:
            print(f'you got A your marks {self.marks}')
        elif self.marks>= 70 & self.marks<=79:
            print(f'you got B+ your marks {self.marks}')
        elif self.marks>= 60 & self.marks<=69:
            print(f'you got C your marks {self.marks}')
        else: 
            self.marks<self.minimum_marks
            print(f'you are failed and your result {self.marks}')

Student = Exam('Anis', 99)
Student.result(60)


                    
                                        Module 5.6 Shopping Cart

"""Shopping Cart System"""

class Shopping:
    
    def __init__(self, name):
        self.name = name
        self.cart =[] #this is a  list
    
    def add_to_cart(self, item, price, quantity):
        product={'item':item, 'price':price, 'quantity':quantity} #this is dictionary (key: value pair)
        self.cart.append(product)
    
    def checkout(self, amount):
        total = 0
        print('Your Listed Item:')
        for item in self.cart:
            print(item)
            total += item ['price'] * item ['quantity']
        print('Your Total bill',total)
        
        if total>amount:
            print(f'Sorry! you have to pay {total-amount} more')
        else:
            extra= amount-total
            print(f'Your cash return', extra)
            

Anis = Shopping('Anisul Islam')
Anis.add_to_cart('Alu', 60, 9)
Anis.add_to_cart('Kodu', 30, 5)
Anis.add_to_cart('Letus', 300, 1)

# print(Anis.cart)
Anis.checkout(991)



                        Module 5.7 Multiple Class
                        
class Student:
    def __init__(self, name, current_class, id):
        self.name= name
        self.id=id
        self.current_class=current_class
    def __repr__(self): #__repr__ this function define to representing the value of class which are directly sent from object. If we want to show some information which are send from object and directly print that than we have to use __repr__()
        return f'Student with name {self.name}, class: {self.current_class}, id: {self.id}'

class Teacher:
    def __init__(self, name, id, subject):
        self.name=name
        self.id=id
        self.subject=subject
    
    def __repr__(self) -> str:
        return f'Teacher\'s name: {self.name}, Subject\'s name:{self.subject}, id: {self.id}'
        
class School:
    def __init__(self, name) -> None:
        self.name=name
        self.teachers=[]
        self.students=[]
        
    def add_teacher(self,name, subject):
        id = len(self.teachers) + 101
        teacher=Teacher(name, subject, id)
        self.teachers.append(teacher)
    
    def enroll(self, name, fee):
        if fee < 6500:
            return 'not enough fee'
        else:
            id = len(self.students)+1
            student=Student(name,'c',id)
            self.students.append(student)
            return f'{name} is enroll with id: {id}, extra money{fee-6500}'

    def __repr__(self) -> str:
        print('welcome to', self.name)
        for teacher in self. teachers:
            print(teacher)
        
        for student in self.students:
            print(student)
            
        
# alia=Student('Alia', 6, 220)
# print(alia)
# anis=Teacher('Anis', 'C++', 220238063)
# print(anis)
phitron = School('Phirton')
phitron.enroll('Anis', 9000)
phitron.enroll('kaliya', 7000)
phitron.enroll('Baliya', 8000)
phitron.add_teacher('D.das', 'DS')
phitron.add_teacher('SK.das', 'java')
print(phitron)


                    6.1 OOPS

class Company:
    def __init__(self,name, address):
        self.name=name
        self.bus=[]
        self.routes=[]
        self.drivers=[]
        self.counter=[]
        self.manager=[]
        self.supervisor=[]
        pass

class Driver:
    def __init__(self, license, name, age):
        self.license=license
        self.name=name
        self.age=age

class Counter:
    def __init__(self) -> None:   
        pass

class Passenger:
    pass

class supervisor:
    pass






                                6.2 Common and uncommon

    #based class, parent class/ Inheritance
# derived class, child class,

"""This Device class are the common class or parent class and the other class
    are child class. So child class can inherit the parent class. So, If we need something from the parent class we can access.
    It was very helpful for not repeating code and less time complexity.
"""
class Device:
    def __init__(self, brand, price,color, origin):
        self.brand=brand
        self.price=price
        self.color=color
        self.color=origin
        
    def __init__(self,memory):
       
        self.memory=memory
    
    def run(self):
        return f'Running Laptop: {self.brand}'
    
    def coding(self):
        return f'learning python and practicing'
    
    
class Phone:
    def __init__(self, dual_sim):
    
        self.dual_sim = dual_sim

    def phone_call(self, number,text):
        return f'send sms to: {number} with: {text}'

class Camera:
    def __init__(self, pixel):
        
        self.pixel=pixel
    
    def change_lens(self):
        pass


                                
                                
                                6.3 Multi Level Inheritance

# # #based class, parent class/ Inheritance
# # # derived class, child class,

# # """This Device class are the common class or parent class and the other class
# #     are child class. So child class can inherit the parent class. So, If we need something from the parent class we can access.
# #     It was very helpful for not repeating code and less time complexity.
# # """
# # class Device:
# #     def __init__(self, brand, price,color, origin):
# #         self.brand=brand
# #         self.price=price
# #         self.color=color
# #         self.color=origin
        
# #     def __init__(self,memory):
       
# #         self.memory=memory
    
# #     def run(self):
# #         return f'Running Laptop: {self.brand}'
    
# #     def coding(self):
# #         return f'learning python and practicing'
    
    
# # class Phone:
# #     def __init__(self, dual_sim):
    
# #         self.dual_sim = dual_sim

# #     def phone_call(self, number,text):
# #         return f'send sms to: {number} with: {text}'

# # class Camera:
# #     def __init__(self, pixel):
        
# #         self.pixel=pixel
    
# #     def change_lens(self):
# #         pass



# """Another Example"""
# class Vehicle:
#     def __init__(self, name,  price):
#         self.name=name
#         self.price=price
    
#     def __repr__(self) -> str:
#         return f'Vechile Name: {self.name}, price{self.price}'
    
#     def move(self):
#         pass
# class Bus(Vehicle):
#     def __init__(self, name, price, seat):
#         self.seat=seat
#         super().__init__(name, price)
    
#     def __repr__(self) -> str:
#         return super().__repr__()

# class Truck(Vehicle):
#     def __init__(self, name, price, weight):
#         self.weight=weight
#         super().__init__(name, price)

# class Picktup(Truck):
#     def __init__(self, name, price, weight):
#         super().__init__(name, price, weight)

# class ACBus(Bus):
#     def __init__(self, name, price, seat,temparature):
#         self.temparature=temparature
#         super().__init__(name, price, seat)
#     def __repr__(self) -> str:
#         return f'Vehicle Name: {self.name}, vehicle price: {self.price}, total seat {self.seat}, temparature {self.temparature}'

# Green_line=ACBus('Greeen', 10000000, 40, 21)
# print(Green_line)


"""Example 3 multi level inheritance"""
# class Batch:
#     def __init__(self,section):
#         self.section=section
    
#     def __repr__(self) -> str:
#         pass

# class Section(Batch):
#     def __init__(self, section, ID):
#         self.ID=ID
#         super().__init__(section)

# class ID(Section):
#     def __init__(self, section, ID, name):
#         self.name=name
#         super().__init__(section, ID)

# class Student(ID):
#     def __init__(self, section, ID, name, Weight, Height, Age):
#         self.Weight=Weight
#         self.Height=Height
#         self.Age=Age
#         super().__init__(section, ID, name)
    
#     def __repr__(self) -> str:
#         return f'Section {self.section}, Id: {self.ID}, Name: {self.name}, Weight: {self.Weight},Height: {self.Height}, Age: {self.Age}'

# Anis = Student('B', 220238063, 'Md Anisul Islam', 75, '5\'7', 23)
# print(Anis)




                        6.4 Multiple Inheritance

class Family:
    def __init__(self, address):
        self.address=address

class School:
    def __init__(self, id, level):
        self. id = id
        self. level =level

class Sports:
    def __init__(self, game):
        self.game = game

class Student(Family, School, Sports):
    def __init__(self, address, id, level, game):
        School.__init__(self, id, level)
        Sports.__init__(self, game)
        super().__init__(address)
    
        

                        6.5 Encapsulation and access modifiers

class Bank:
    def __init__(self, holder_name, initial_deposit):
        self.holder_name=holder_name
        self.__balance=initial_deposit
    def deposit(self, amount):
        self.__balance +=amount
    
    def get_balance(self):
        return self.__balance

anis = Bank('anis',1000)
print(anis.holder_name)
anis.deposit(4000)
print(anis.get_balance())



                        6.6 Abstract Classes and abstractmethod

from abc import ABC, abstractclassmethod #abstract class importing
class Animal(ABC): #abstract method calling  ABC mean Abstract Base Class
    @abstractclassmethod #abstractmethod use for identifying which method is need to abstract
    def eat(self):
        pass
    @abstractclassmethod 
    def move(self):
        pass

class Anis(Animal):
    def __init__(self, name) -> None:
        self.category='Anisul'
        self.name=name
        super().__init__()
    def eat(self):
        print('from eat method')
    
    def move(self):
        print('Khaifa Halek')

Anisul=Anis('Khana dao')
Anisul.eat()
Anisul.move()

""""@abstractclassmethod is the process or way where you can from django.conf import settings
a sub class to create the same method which are already on  parent class method.  
"""


                        6.8 Polymorphism

class Shape:
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, name, radius) -> None:
        self.radius=radius
        self.name=name
    
    def area(self):
        result= 3.1416*self.radius**2
        return result
    
class Rectangle(Shape):
    def __init__(self, name, height, width) -> None:
        self.height=height
        self.width=width
        self.name=name
        
    def area(self):
        result= self.height*self.width
        return result


circle=Circle('circle',4)
print(f'Here is area of {circle.name} {circle.area()}')

rectangle=Rectangle('Rectangle', 20, 4)
print(f'Here is area of {rectangle.name} {rectangle.area()}')
    


                        Module 7.1. Overloading & Overriding

    #Example for Overriding
"""
class Person:
    def __init__(self, name, age, height, weight) -> None:
        self.name=name
        self.age=age
        self.height=height
        self.weight=weight
    
    def eat(self):
        print('Food for ordinary')

class Myself(Person):
    def __init__(self, name, age, height, weight, team) -> None:
        self.team=team
        super().__init__(name, age, height, weight)
        
    def eat(self):  #this function overriding the main class function
        print('Birani')


Anis=Myself('Anis', 23, 57, 75, 'B')
Anis.eat()
"""

#Example for Overloading
class Person:
    def __init__(self, name, age, height, weight) -> None:
        self.name=name
        self.age=age
        self.height=height
        self.weight=weight
    
    def eat(self):
        print('Food for ordinary')

class Myself(Person):
    def __init__(self, name, age, height, weight, team) -> None:
        self.team=team
        super().__init__(name, age, height, weight)
        
    def eat(self):  #this function overriding the main class function
        print('Birani')
    
    # + sign overload
    def __add__(self, other):
        return self.age+other.age
    
    # - sign overload
    def __sub__(self,other):
        return self.age-other.age
    
    # * sign overload
    def __mul__(self,other):
        return self.age*other.age
    
     # > sign overload
    def __gt__(self,other):
        return self.age>other.age


Anis=Myself('Anis', 23, 57, 75, 'B')
Sakiya=Myself('Sakiya', 22, 54, 65, 'B')
print(Anis+Sakiya)
print(Anis-Sakiya)
print(Anis*Sakiya)
print(Anis>Sakiya)


"""
Other method are here:



    Initialization and Construction

        __new__: To get called in an object’s instantiation.
        __init__: To get called by the __new__ method.
        __del__: It is the destructor.

    Numeric magic methods

        __trunc__(self): Implements behavior for math.trunc()
        __ceil__(self): Implements behavior for math.ceil()
        __floor__(self): Implements behavior for math.floor()
        __round__(self,n): Implements behavior for the built-in round()
        __invert__(self): Implements behavior for inversion using the ~ operator.
        __abs__(self): Implements behavior for the built-in abs()
        __neg__(self): Implements behavior for negation
        __pos__(self): Implements behavior for unary positive 

    Arithmetic operators

        __add__(self, other): Implements behavior for math.trunc()
        __sub__(self, other): Implements behavior for math.ceil()
        __mul__(self, other): Implements behavior for math.floor()
        __floordiv__(self, other): Implements behavior for the built-in round()
        __div__(self, other): Implements behavior for inversion using the ~ operator.
        __truediv__(self, other): Implements behavior for the built-in abs()
        __mod__(self, other): Implements behavior for negation
        __divmod__(self, other): Implements behavior for unary positive 
        __pow__: Implements behavior for exponents using the ** operator.
        __lshift__(self, other): Implements left bitwise shift using the << operator.
        __rshift__(self, other): Implements right bitwise shift using the >> operator.
        __and__(self, other): Implements bitwise and using the & operator.
        __or__(self, other): Implements bitwise or using the | operator.
        __xor__(self, other): Implements bitwise xor using the ^ operator.

    String Magic Methods

        __str__(self): Defines behavior for when str() is called on an instance of your class.
        __repr__(self): To get called by built-int repr() method to return a machine readable representation of a type.
        __unicode__(self): This method to return an unicode string of a type.
        __format__(self, formatstr): return a new style of string.
        __hash__(self): It has to return an integer, and its result is used for quick key comparison in dictionaries.
        __nonzero__(self): Defines behavior for when bool() is called on an instance of your class. 
        __dir__(self): This method to return a list of attributes of a class.
        __sizeof__(self): It return the size of the object.

    Comparison magic methods

        __eq__(self, other): Defines behavior for the equality operator, ==.
        __ne__(self, other): Defines behavior for the inequality operator, !=.
        __lt__(self, other): Defines behavior for the less-than operator, <.
        __gt__(self, other): Defines behavior for the greater-than operator, >.
        __le__(self, other): Defines behavior for the less-than-or-equal-to operator, <=.
        __ge__(self, other): Defines behavior for the greater-than-or-equal-to operator, >=.



"""


                                    7.2 Static Attribute

                                    SKIP


                                    Module 7.3 Getter & Setter
                
# """
#     1. Read only ----> you cannot set the value. value cannot be changed.
#     2. getter --> get a value of a property. Most of the time you will get the value of a privete attribute.
#     3. setter---> set a value of a property through a method, Most of the time, you will set the value of a private property.
# """
# class User:
#     def __init__(self, name, age, money ) -> None:
#         self._name=name #protected variable
#         self._age=age #protected variable
#         self.__money= money #private variable
#     @property #this is getter property by default read only attribute.
#     def age(self):
#         return self._age
    
#     @property
#     def salary(self):
#         return self.__money
    
#     @salary.setter  #this is "setter" attribute. For setting setter attribute first you have to mention the method name which have to set setter that .setter
#     def salary(self, value):
#         if value<0:
#             return f'you have not enough money!'
        
#         else: 
#              self.__money+=value
        
    
# samsu = User('Anis', 23, 12000)

# # print(samsu.__money)
# #print(samsu.age()) 
# """now this age is behaving like method 
# but if we need to call it like a attribute than we can use 
# ""  @property ""  upon on that method
# """
# print(samsu.age) 
# print(samsu.salary)
# samsu.salary=500
# print(samsu.salary)

class User:
    def __init__(self, name, age, money) -> None:
        self._name=name
        self._age=age
        self.__money=money
    @property
    def age(self):
        return self._age
    
    @property
    def salary(self):
        return self.__money
    
    @salary.setter
    def salary(self, value):
        if value<0:
            return f'Ami Fokir'
        else:
            self.__money+=value

Anis= User('Anis', 23, 12000)
print(Anis.age)
print(Anis.salary)
Anis.salary=1200
print(Anis.salary)


                            MOdule 7.4 Understaing Wrapper function and Inner funciton

#function is a first class object
def double_decker():
    print('starting the double decker')
    def inner_fun():
        print('inside the inner')
        # return 3000
    return inner_fun

def func(double_decker):
    print('Alpha Alpha')
    double_decker()
    print('Beta')

def pentu():
    print('decorator way or wrapper function')
#print(double_decker()()) #calling the inner fucntion using double ()
func(pentu)

#decorator


                        Module 7.5 How does decorator work

 def functionn(hbd):
    def innerfunc():
        print('Alif Laila')
        hbd()
        print('Chomolokko')
    return innerfunc
@functionn  #easy mehtod to use decorator
def get_factorial():
    print('factorial starting')

get_factorial()

"""Without decorator if i call
    the below function it will give
    the out put of himself. But when using @and_mention_the_main_function
    then the main function will call and a argument pass from the second_function()
    after that the main fucntion will receive as parameter then it will show the result. 
"""    

                    
                    Module 7.6 Class Composition Inheritance vs Composition

# Inheritance and composition are two fundamental concepts in object-oriented programming that allow you to design and structure your code. They serve different purposes and have their own advantages and use cases. Let's explore both concepts:
# Inheritance:

#     Inheritance is an "is-a" relationship where one class derives properties and behaviors from another class. It allows you to create a new class based on an existing class, inheriting its attributes and methods.
#     The new class (subclass or derived class) can extend or modify the behavior of the existing class (base class or superclass) and also add its own attributes and methods.
#     Inheritance promotes code reusability by allowing you to use and build upon existing classes. It can help you model hierarchies and relationships between objects.
#     However, it can lead to tight coupling between classes, making the code harder to maintain and less flexible, especially if the inheritance hierarchy becomes deep and complex.

# Example:

# python

# class Vehicle:
#     def __init__(self, wheels):
#         self.wheels = wheels

# class Car(Vehicle):
#     def __init__(self, wheels, brand):
#         super().__init__(wheels)
#         self.brand = brand

# Composition:

#     Composition is a "has-a" relationship that allows you to create complex objects by combining and using instances of other classes. It involves creating objects of one class within another class.
#     Composition promotes flexibility and loose coupling, as you can change the behavior of a class by swapping out its components without affecting the entire class.
#     It's often more suitable when you need to build complex systems with reusable components. Composition is favored over inheritance when designing for flexibility and maintainability.

# Example:

# python

#     class Engine:
#         def start(self):
#             print("Engine started")

#     class Car:
#         def __init__(self):
#             self.engine = Engine()

#         def drive(self):
#             print("Driving the car")
#             self.engine.start()

# In summary, the choice between inheritance and composition depends on your design goals. If you want to create a hierarchy of closely related classes with shared characteristics, inheritance can be appropriate. If you want to build flexible, maintainable, and loosely coupled systems, composition is often a better choice. In practice, a combination of both inheritance and composition is frequently used to achieve the desired design and code structure.

# other example: https://www.geeksforgeeks.org/inheritance-and-composition-in-python/


# class Animal:
#     pass

# """"Inheritance provides you is a relation

#     composition:
# """
# #Dog is an animal
# class Dog(Animal):
#     pass
# #Dog is an animal
# class Tiger(Animal):
#     pass

# class Furniture:
#     pass

# #chair is a furniture
# class Chair(Furniture):
#     pass

# class Table(Furniture):
#     pass


# """Composition"""
# #Example for compostition
# class Engine:
#     def __init__(self) -> None:
#         pass
    
#     def start(self):
#         return "Engine Started"


# class Driver:
#     def __init__(self) -> None:
#         pass
    
# class Car:
#     def __init__(self) -> None:
#         self.engine=Engine()
#         self.driver=Driver()
    
#     def start(self):
#         self.engine.start()

class CPU:
    def __init__(self, core) -> None:
        self.core=core

class RAM:
    def __init__(self, size) -> None:
        self.size=size

class HardDrive:
    def __init__(self, capacity) -> None:
        self.capacity=capacity

class Computer:
    def __init__(self, core, ram_size, hd_capacity) -> None:
        self.cpu=CPU(core)
        self.ram=RAM(ram_size)
        self.hard_disc=HardDrive(hd_capacity)
        
mac=Computer(4,8,512)
print( f'The cpu size is {mac.cpu.core}, Hard Disk:{mac.hard_disc.capacity} Ram size: {mac.ram.size}')

#Other way:
# # Define the values you want to set for CPU cores, RAM size, and hard drive capacity
# core_count = 4  # Number of CPU cores
# ram_size_gb = 16  # RAM size in gigabytes
# hd_capacity_gb = 512  # Hard drive capacity in gigabytes

# # Create a Computer object with the specified values
# my_computer = Computer(core_count, ram_size_gb, hd_capacity_gb)

# # Access the components of the computer
# print("CPU Cores:", my_computer.cpu.core)
# print("RAM Size (GB):", my_computer.ram.size)
# print("Hard Drive Capacity (GB):", my_computer.hard_disc.capacity)





                                            Module 7.7 UML design

UML is mainly use for making the pictorial allignment design how class are interect with other class and object. This
is use for software designing. 


    UML stands for Unified Modeling Language.

    UML is different from the other common programming languages such as C++, Java, COBOL, etc.

    UML is a pictorial language used to make software blueprints.

    UML can be described as a general purpose visual modeling language to visualize, specify, construct, and document software system.

    Although UML is generally used to model software systems, it is not limited within this boundary. It is also used to model non-software systems as well. For example, the process flow in a manufacturing unit, etc.

For more: 
https://www.tutorialspoint.com/uml/uml_building_blocks.htm