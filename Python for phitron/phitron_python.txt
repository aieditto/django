                                                #Introduction to python
                                       
                                       #Date 1st 1st module date: 17th june,2023
                                                     #Module 1.3:
                                          #Basic data type and variable in python

"""python no need to declare any data type for the variable so it was easy to handle and most easy language".
"""
# age = 45
# print(age)
# collusion = "substitute"
# print(collusion)
# is_signle = True
# print(is_signle)

# #to know the type of the variable
# is_single=True
# print(type(is_signle))
# is_singele="Fuck you"
# print(type(is_singele))

                                  #Module 1.4 Basic input and output typecasting
# #How to take input
# money = input("Give me money:")
# print("here is money:" ,money)

# # When we add some values and use input() function but 
# # that time it take as a string so we have to apply typecast  for
# # changing the data type. Here are some example

# firstmoney=input("Enter money 1: ")
# secondmoney=input("Enter money 2: ")
# first=int(firstmoney)
# second=int(secondmoney)
# total=first+second
# print("Total money:",total)




                                # python 2nd day 2nd module date sat, 27 may, 2023
                                                    # fucntion

"""
2.1 introduction to function in python
indentation means space it work as a bracket.

def is called define.
function likte gele def likte hoi
"""
# def double_it(num):
#     result=num*2
#     print(result)

# double_it(8)
# double_it(88)

# def sum(num1,num2):
#     result= num1+num2
#     return result
# total = sum(23,45)
# print(total)

"""
2.2 Default parameters and args in python


"""
# def sum(num1,num2,num3): 
#     # """this are called argument where the value add at the bracket"""
#     result= num1+num2+num3
#     return result
# total = sum(99,11,5) 
# # """this are called parameter where the value add at the bracket"""
# print('total:',total)

# """jodi parameter 2ta pataite hoi but argument 3ta rakte hoi
# tahole j parameter ta patabona shetak 0 diye assign korte hbe jemon
# num3=0
# """
# def sum(num1,num2,num3=0): 
#     # """this are called argument where the value add at the bracket"""
#     result= num1+num2+num3
#     return result
# total = sum(99,11) 
# # """this are called parameter where the value add at the bracket"""
# print('total:',total)

"""
If i need to add many number on the arguments but I dont no how many numbers
need to add there also I dont want to add num=0 repeatedly. That's why tupple are use.
Tupple is like one kind of array or list.

what is tupple?
A tuple is a data structure in programming that is used to store multiple elements together. 
It is an ordered collection of values, enclosed in parentheses and separated by commas. 
Tuples are similar to lists or Array, but they are immutable, meaning their elements cannot be modified once they are created.
Tuples can contain elements of different data types, such as integers, floats, strings, or even other tuples.

The procude for write tupple:
def all_sum(*numbers): //here adding (*) before the arguments are tupple
    print(numbers)

total = all_sum(12,23,5,7,8)
print(total)
"""



#                   #2.3 (advanced) kargs, multiple return from a function
# def func(a,b):
#     nul=f'showing the value: {a},{b}'
#     return nul

# nul=func(1,2)
# print(nul)

#                         #2.4 Local and global variable
# amount = 3000 #global variable
# def take_amount(item,taka):
#     #taka =2000 #local variabl
#     global amount #global  is a keyword use for accesing global variable
#     amount= amount-taka
#     print(f'Show the amount of the {item} ',amount)

# take_amount('Chocolate',1000)


#2.5 Module Built in function and import module
# def taka_dao(taka):
#     Fachis_dinme_paisa_double = 2*taka
#     print(f'Paisa hi paisa hoga now ap bare lok ho apki total amount:',Fachis_dinme_paisa_double)

# taka_dao(20000)

#fiie 2nd
# from function2ndmodule import taka_dao
# taka_dao(5000000)

# 2.6 list 
# #Normal indexing:
#        #0   1  2   3    4  5   6
# list =[10, 11, 12, 23, 45, 67, 8]
#        #-6  -5  -4  -3  -2  -1  0
# #printing value of index 0 to before 2 
# print(list[0:2])
# #printing value of index 1 to before 6 
# print(list[1:6])
# #python has the power of printing without mentioning the index. for example
# # if before and after of colon ':' has no value or given only one value it will automatically
# # produce the 1st or last index 
# print(list[:6])
# print(list[0:])
# print(list[:])
# print(list[1:6:2])
 
                                # Module 3.1
# If i want to write a name with single quotation
# like abdur's rahman then it will show a error
# thats why I have to use (/) 
# example: abdur\'s rahman

# name = 'anisul\'s islam' #this is call escaping
# name2= 'love'
# name3= """Sakiya tuj johor mumu"""
# print(name)
# print(name2)
# print(name3)


#string is a sequence of character
#list are called that means changeable and non-mutable means unchangeable
#string cant be change 
# for example:
# name2[0]='F'
# print(name2)
# this error will be show:
#  File "g:\Python for phitron\function2ndmodule.py", line 174, in <module>
#     name2[0]='F'
#     ~~~~~^^^
# TypeError: 'str' object does not support item assignment
# print(name2[2])#findout the value of input index
# print(name3[::-1])#string canbe reversable
# print(name3[1:6])#string can sliceable

                            
                            
                            # Moudle 3.2
#Tupple is one kind of list where many values are store
# #tupple cant be changeable like assigning any value
# print(len(name))
# item = ([0,2,6],[5,99,7],[4,7,991])
# print(item)
# #After changing the single value of the list of single tupple
# print("After changing the single value")
# item [0][1]= 45
# item [2][0]= 23
# print(item)

 # #Module 3.3 Set and set methods in python
# # Set is a unique item

"""         List --> []

            tupple --> ()
            
            set --> {}
"""
# numbers=[12,56,98,78,56,12,6,98]
# print(numbers)
# number_set=set(numbers)
# print(number_set)

# #number add
# number_set.add(47)
# print(number_set)

# #remove
# number_set.remove(6)
# print(number_set)

# len(number_set)

# A= {5,6,8,9}
# B= {10,6,9}
# print(A&B)
#  other things are on websites

                            
                            
                             #Module-3.4 Dictionary and Dictionary methods in python

# Dictionary is like key value pair
# numbers = [12,56,98,78,56,12,26,98]
# person1 =['Anis', 'Kalipur', 23, 'student']
# # {key: valuem, key: value, key:value}
# person ={'name':'Anis', 'Address': 'Saltgola','Age': 23, 'Job':'Student'}
# print(person)
# print(person['Job'])
# # Dictionaries are mutable so I can change any of the value from the list or tuple
# print("Biyer age")
# person2 ={'Name':'Sakiya Tuj Johora', 'Address': 'Hulaine, Badamtol','Age': 22, 'Profession':'Amr Bou'}
# print(person2)
# print(person2['Profession'])
# print(person2.keys()) #for printing the keys of dictionaries
# print(person2.values())  #for printing the values of dictionaries

# print("Biyer Por")
# person2['Jamai']='Anis'
# print(person2)
# person2['Address']='Anis er bari'
# print(person2)

# other things are found on website

# import pyautogui
# from time import sleep
# sleep(10)

# pyautogui.write("bepar ta kintu moja onk", interval=0.01)
# pyautogui.press('enter',presses=1)


                            
                            
                            
                                Introduction to Simple Class Module 5.1

class is an entity where data and object wrap up together
class carries many info which are used in other class or other place

How to write class and object and use that?

            class class_name:
                instruction

            object = class_name()
            object.instruction= value
            print(object.instruction)
Example:
        # class Class_name:
        #     price=19000
        #     color='blue'
        #     brand='samsung'

        # my_phone=Class_name()
        # print(my_phone)
        # print(my_phone.price)
        # print(my_phone.color)
        # print(my_phone.brand)

        class student:
            id=''
            roll=''
            section=''

        Anis=student()
        Sakiya=student()

        Anis.id= 220238063
        Anis.roll= 63
        Anis.section= 'B'
        print(Anis.id)
        print(Anis.roll)
        print(Anis.section)

        Sakiya.id= 220238048
        Sakiya.roll= 48
        Sakiya.section= 'B'
        print(Sakiya.id)
        print(Sakiya.roll)
        print(Sakiya.section)


                            
                            
                            
                              Module  5.2 Creating and Using Methods

# def function():
#     print('calling someone i dont know')
#     return 'call done'
# class phone:
#     price = 1200
#     color= 'yellow'
#     brand='sandy'
#     features=['camera', 'speaker']
    
#     def call(self): 
#         # self is use for calling the method in class
#         print('calling one person')
    
#     def send_sms(self, xhone, message):
#         text= f'send message to {xhone} and sms {message}'
#         return text

# amar_phone= phone()
# print(amar_phone.features)

# busy= amar_phone.call()
# result= amar_phone.send_sms(233, 'Inky pinky ponky')
# print(result)

class Calculator:
    brand= 'Casio 6251'
    def add(self, num1, num2):
        result= num1+num2
        return result
    def sub(self, num1, num2):
        result2= num1-num2
        return result2

addition=Calculator()
print(addition.brand)
result=addition.add(55,5)
print(result)

result2=addition.sub(5,2)
print(result2)


                        
                        
                        
                              Module  5.3 Constructors and __init__ in python

  # __init__ mean initialize which are use as constructor
  in python class init is use like the constructor
  constructor means a class which have some variable or instruction
  that are use on object  which have similar characteristics
  and it also like the DRY(Django) princle that means Dont Repeat Yourself
  so it give less time complexity and short to typing code repeatedly.

    The Default __init__ Constructor in C++ and Java. Constructors are used to initializing the object’s state. The task of constructors is to initialize(assign values) to the data members of the class when an object of the class is created. Like methods, a constructor also contains a collection of statements(i.e. instructions) that are executed at the time of Object creation. It is run as soon as an object of a class is instantiated. The method is useful to do any initialization you want to do with your object.

 class Phone:
     manufacture ='China'
    
     def __init__(self, owner, brand,price):
         self.owner=owner
         self.brand=brand
         self.price=price
        
       
        
     def send_msg(self, phone, sems):
         text= f'sending to: {phone} {sems}'
         print(text)
    

# my_phone= Phone('Anis', 'tecno', '8500')
# print(my_phone.owner, my_phone.brand, my_phone.price)

class Phone:
    
    def __init__(self, num1, num2):
        self.num1=num1
        self.num2=num2
        
addition=Phone(10,19)
result=addition.num1+addition.num2
print(f'{addition.num1} + {addition.num2} = {result}')

sub=Phone(14,5)
result2=sub.num1-sub.num2
print(f'{sub.num1} - {sub.num2} = {result2}')

                
                
                
                   Module  5.4 Class Attributes vs instance attributes

# Class Attribute VS Instance Attribute

class Shop:
    cart=[] #list declare class attribute this for all not in function
    def __init__(self,buyer): #init funciton for construction
        self.buyer = buyer #attribute declare
        
    def add_to_cart(self, item):
        self.cart.append(item)

customer = Shop('Anisul Islam')
customer.add_to_cart('Audi')
customer.add_to_cart('Ferari')
customer.add_to_cart('Marcedies')
print(customer.cart)

customer2 = Shop('Anisul Islam')
customer2.add_to_cart('Audi')
customer2.add_to_cart('Ferari')
customer2.add_to_cart('Marcedies')
print(customer2.cart)


class Shop:
     
    def __init__(self,buyer): #init funciton for construction
        self.buyer = buyer #attribute declare
        self.cart=[] #instant attribute #list declare  this for all not in function
        
    def add_to_cart(self, item):
        self.cart.append(item)

customer = Shop('Anisul Islam')
customer.add_to_cart('Audi')
customer.add_to_cart('Ferari')
customer.add_to_cart('Marcedies')
print(customer.cart)

customer2 = Shop('Sakiya Islam')
customer2.add_to_cart('Lipstick')
customer2.add_to_cart('Eyeliner')
customer2.add_to_cart('Brush')
print(customer2.cart)

what is the big difference?
the difference is when using class attribute this are for all other function and object
so when two or many object are create and call the class the class attribute work for all of them as a result we see if difference object has different items but the result will show all item in one list. 

But if we use instance attribute
it will work separtely and give the result separately.


                                    
                                    
                                    
                                    
                                    Module- 5.5 Bank System


# class Bank:
#     def __init__(self, balance):
#         self.balance=balance
#         self.min_withdraw=100
#         self.max_withdraw=10000
    
#     def get_balance(self):
#         return self.balance
    
#     def deposit(self, amount):
#         if amount> 0:
#             self.balance += amount
#             print(f'your balance is{self.balance}')
    
#     def withdraw(self,amount):
#         if amount<self.min_withdraw:
#             print(f'Sorry. Minimum withdraw is{self.min_withdraw}')
#         elif amount>self.max_withdraw:
#             print(f'Sorry. Maximum withdraw is {self.max_withdraw}')
#         else:
#             self.balance-=amount
#             print(f'Your Balance {self.get_balance()}')   

# dbl=Bank(5000)
# dbl.withdraw(101)

class Exam:
    
    def __init__(self, person, marks):
        self.person=person
        self.marks=marks
        print(f'student name{self.person}')
        self.minimum_marks=33
    
    # def max(self):
        
    
    def result(self, marks):
        if self.marks>90:
            print(f'you got A+ your marks {self.marks}')
        elif self.marks>= 80 & self.marks<=89:
            print(f'you got A your marks {self.marks}')
        elif self.marks>= 70 & self.marks<=79:
            print(f'you got B+ your marks {self.marks}')
        elif self.marks>= 60 & self.marks<=69:
            print(f'you got C your marks {self.marks}')
        else: 
            self.marks<self.minimum_marks
            print(f'you are failed and your result {self.marks}')

Student = Exam('Anis', 99)
Student.result(60)


                    
                                        Module 5.6 Shopping Cart

"""Shopping Cart System"""

class Shopping:
    
    def __init__(self, name):
        self.name = name
        self.cart =[] #this is a  list
    
    def add_to_cart(self, item, price, quantity):
        product={'item':item, 'price':price, 'quantity':quantity} #this is dictionary (key: value pair)
        self.cart.append(product)
    
    def checkout(self, amount):
        total = 0
        print('Your Listed Item:')
        for item in self.cart:
            print(item)
            total += item ['price'] * item ['quantity']
        print('Your Total bill',total)
        
        if total>amount:
            print(f'Sorry! you have to pay {total-amount} more')
        else:
            extra= amount-total
            print(f'Your cash return', extra)
            

Anis = Shopping('Anisul Islam')
Anis.add_to_cart('Alu', 60, 9)
Anis.add_to_cart('Kodu', 30, 5)
Anis.add_to_cart('Letus', 300, 1)

# print(Anis.cart)
Anis.checkout(991)



                        Module 5.7 Multiple Class
                        
class Student:
    def __init__(self, name, current_class, id):
        self.name= name
        self.id=id
        self.current_class=current_class
    def __repr__(self): #__repr__ this function define to representing the value of class which are directly sent from object. If we want to show some information which are send from object and directly print that than we have to use __repr__()
        return f'Student with name {self.name}, class: {self.current_class}, id: {self.id}'

class Teacher:
    def __init__(self, name, id, subject):
        self.name=name
        self.id=id
        self.subject=subject
    
    def __repr__(self) -> str:
        return f'Teacher\'s name: {self.name}, Subject\'s name:{self.subject}, id: {self.id}'
        
class School:
    def __init__(self, name) -> None:
        self.name=name
        self.teachers=[]
        self.students=[]
        
    def add_teacher(self,name, subject):
        id = len(self.teachers) + 101
        teacher=Teacher(name, subject, id)
        self.teachers.append(teacher)
    
    def enroll(self, name, fee):
        if fee < 6500:
            return 'not enough fee'
        else:
            id = len(self.students)+1
            student=Student(name,'c',id)
            self.students.append(student)
            return f'{name} is enroll with id: {id}, extra money{fee-6500}'

    def __repr__(self) -> str:
        print('welcome to', self.name)
        for teacher in self. teachers:
            print(teacher)
        
        for student in self.students:
            print(student)
            
        
# alia=Student('Alia', 6, 220)
# print(alia)
# anis=Teacher('Anis', 'C++', 220238063)
# print(anis)
phitron = School('Phirton')
phitron.enroll('Anis', 9000)
phitron.enroll('kaliya', 7000)
phitron.enroll('Baliya', 8000)
phitron.add_teacher('D.das', 'DS')
phitron.add_teacher('SK.das', 'java')
print(phitron)


                    6.1 OOPS

class Company:
    def __init__(self,name, address):
        self.name=name
        self.bus=[]
        self.routes=[]
        self.drivers=[]
        self.counter=[]
        self.manager=[]
        self.supervisor=[]
        pass

class Driver:
    def __init__(self, license, name, age):
        self.license=license
        self.name=name
        self.age=age

class Counter:
    def __init__(self) -> None:   
        pass

class Passenger:
    pass

class supervisor:
    pass






                                6.2 Common and uncommon

    #based class, parent class/ Inheritance
# derived class, child class,

"""This Device class are the common class or parent class and the other class
    are child class. So child class can inherit the parent class. So, If we need something from the parent class we can access.
    It was very helpful for not repeating code and less time complexity.
"""
class Device:
    def __init__(self, brand, price,color, origin):
        self.brand=brand
        self.price=price
        self.color=color
        self.color=origin
        
    def __init__(self,memory):
       
        self.memory=memory
    
    def run(self):
        return f'Running Laptop: {self.brand}'
    
    def coding(self):
        return f'learning python and practicing'
    
    
class Phone:
    def __init__(self, dual_sim):
    
        self.dual_sim = dual_sim

    def phone_call(self, number,text):
        return f'send sms to: {number} with: {text}'

class Camera:
    def __init__(self, pixel):
        
        self.pixel=pixel
    
    def change_lens(self):
        pass


                                
                                
                                6.3 Multi Level Inheritance

# # #based class, parent class/ Inheritance
# # # derived class, child class,

# # """This Device class are the common class or parent class and the other class
# #     are child class. So child class can inherit the parent class. So, If we need something from the parent class we can access.
# #     It was very helpful for not repeating code and less time complexity.
# # """
# # class Device:
# #     def __init__(self, brand, price,color, origin):
# #         self.brand=brand
# #         self.price=price
# #         self.color=color
# #         self.color=origin
        
# #     def __init__(self,memory):
       
# #         self.memory=memory
    
# #     def run(self):
# #         return f'Running Laptop: {self.brand}'
    
# #     def coding(self):
# #         return f'learning python and practicing'
    
    
# # class Phone:
# #     def __init__(self, dual_sim):
    
# #         self.dual_sim = dual_sim

# #     def phone_call(self, number,text):
# #         return f'send sms to: {number} with: {text}'

# # class Camera:
# #     def __init__(self, pixel):
        
# #         self.pixel=pixel
    
# #     def change_lens(self):
# #         pass



# """Another Example"""
# class Vehicle:
#     def __init__(self, name,  price):
#         self.name=name
#         self.price=price
    
#     def __repr__(self) -> str:
#         return f'Vechile Name: {self.name}, price{self.price}'
    
#     def move(self):
#         pass
# class Bus(Vehicle):
#     def __init__(self, name, price, seat):
#         self.seat=seat
#         super().__init__(name, price)
    
#     def __repr__(self) -> str:
#         return super().__repr__()

# class Truck(Vehicle):
#     def __init__(self, name, price, weight):
#         self.weight=weight
#         super().__init__(name, price)

# class Picktup(Truck):
#     def __init__(self, name, price, weight):
#         super().__init__(name, price, weight)

# class ACBus(Bus):
#     def __init__(self, name, price, seat,temparature):
#         self.temparature=temparature
#         super().__init__(name, price, seat)
#     def __repr__(self) -> str:
#         return f'Vehicle Name: {self.name}, vehicle price: {self.price}, total seat {self.seat}, temparature {self.temparature}'

# Green_line=ACBus('Greeen', 10000000, 40, 21)
# print(Green_line)


"""Example 3 multi level inheritance"""
# class Batch:
#     def __init__(self,section):
#         self.section=section
    
#     def __repr__(self) -> str:
#         pass

# class Section(Batch):
#     def __init__(self, section, ID):
#         self.ID=ID
#         super().__init__(section)

# class ID(Section):
#     def __init__(self, section, ID, name):
#         self.name=name
#         super().__init__(section, ID)

# class Student(ID):
#     def __init__(self, section, ID, name, Weight, Height, Age):
#         self.Weight=Weight
#         self.Height=Height
#         self.Age=Age
#         super().__init__(section, ID, name)
    
#     def __repr__(self) -> str:
#         return f'Section {self.section}, Id: {self.ID}, Name: {self.name}, Weight: {self.Weight},Height: {self.Height}, Age: {self.Age}'

# Anis = Student('B', 220238063, 'Md Anisul Islam', 75, '5\'7', 23)
# print(Anis)




                        6.4 Multiple Inheritance

class Family:
    def __init__(self, address):
        self.address=address

class School:
    def __init__(self, id, level):
        self. id = id
        self. level =level

class Sports:
    def __init__(self, game):
        self.game = game

class Student(Family, School, Sports):
    def __init__(self, address, id, level, game):
        School.__init__(self, id, level)
        Sports.__init__(self, game)
        super().__init__(address)
    
        

                        6.5 Encapsulation and access modifiers

class Bank:
    def __init__(self, holder_name, initial_deposit):
        self.holder_name=holder_name
        self.__balance=initial_deposit
    def deposit(self, amount):
        self.__balance +=amount
    
    def get_balance(self):
        return self.__balance

anis = Bank('anis',1000)
print(anis.holder_name)
anis.deposit(4000)
print(anis.get_balance())



                        6.6 Abstract Classes and abstractmethod

from abc import ABC, abstractclassmethod #abstract class importing
class Animal(ABC): #abstract method calling  ABC mean Abstract Base Class
    @abstractclassmethod #abstractmethod use for identifying which method is need to abstract
    def eat(self):
        pass
    @abstractclassmethod 
    def move(self):
        pass

class Anis(Animal):
    def __init__(self, name) -> None:
        self.category='Anisul'
        self.name=name
        super().__init__()
    def eat(self):
        print('from eat method')
    
    def move(self):
        print('Khaifa Halek')

Anisul=Anis('Khana dao')
Anisul.eat()
Anisul.move()

""""@abstractclassmethod is the process or way where you can from django.conf import settings
a sub class to create the same method which are already on  parent class method.  
"""


                        6.8 Polymorphism

import math

class Shape:
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius ** 2

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height

    def area(self):
        return 0.5 * self.base * self.height

# Function to calculate and print the area of a shape
def print_area(shape):
    print(f"Area: {shape.area()}")

# Create instances of different shapes
circle = Circle(5)
rectangle = Rectangle(4, 6)
triangle = Triangle(3, 7)

# Call the function to calculate and print the area of different shapes
print_area(circle)     # Outputs: Area: 78.53981633974483
print_area(rectangle)  # Outputs: Area: 24
print_area(triangle)   # Outputs: Area: 10.5
